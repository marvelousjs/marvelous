/*
 * this file is automatically generated for marvelous via zappjs
 * any manual changes to this file will be overwritten with the "mvs" command
 */

import * as http from 'http';
import * as url from 'url';

interface I{{{case gatewayName 'pascal'}}}GatewayClientOpts {
  url: string;
}

interface I{{{case gatewayName 'pascal'}}}GatewayClient {
  {{#each routes}}
  '{{{./uri}}}': {
    {{#each methods}}
    {{{@key}}}: I{{{case ../../gatewayName 'pascal'}}}GatewayClient{{{case @../key 'pascal'}}}{{{case @key 'pascal'}}}Function;
    {{/each}}
  };
  {{/each}}
}

{{#each routes}}
{{#each methods}}
export interface I{{{case ../../gatewayName 'pascal'}}}GatewayClient{{{case @../key 'pascal'}}}{{{case @key 'pascal'}}}Function {
  (request?: I{{{case ../../gatewayName 'pascal'}}}GatewayClient{{{case @../key 'pascal'}}}{{{case @key 'pascal'}}}Request): Promise<I{{{case ../../gatewayName 'pascal'}}}GatewayClient{{{case @../key 'pascal'}}}{{{case @key 'pascal'}}}Response>;
}

export interface I{{{case ../../gatewayName 'pascal'}}}GatewayClient{{{case @../key 'pascal'}}}{{{case @key 'pascal'}}}Request {
  {{#if request.body}}
  body?: I{{{case ../../gatewayName 'pascal'}}}GatewayClient{{{case @../key 'pascal'}}}{{{case @key 'pascal'}}}RequestBody;
  {{/if}}
  {{#if request.params}}
  params?: I{{{case ../../gatewayName 'pascal'}}}GatewayClient{{{case @../key 'pascal'}}}{{{case @key 'pascal'}}}RequestParams;
  {{/if}}
}

export interface I{{{case ../../gatewayName 'pascal'}}}GatewayClient{{{case @../key 'pascal'}}}{{{case @key 'pascal'}}}Response {
  statusCode: number;
  {{#if response.body}}
  body: I{{{case ../../gatewayName 'pascal'}}}GatewayClient{{{case @../key 'pascal'}}}{{{case @key 'pascal'}}}ResponseBody;
  {{/if}}
  headers: {
    authorization?: string;
    contentType?: string;
  }
}

{{#if request.body}}
{{{tsInterface (concat (case ../../gatewayName 'pascal') 'GatewayClient' (case @../key 'pascal') (case @key 'pascal') 'RequestBody') request.body}}}
{{/if}}
{{#if response.body}}
{{{tsInterface (concat (case ../../gatewayName 'pascal') 'GatewayClient' (case @../key 'pascal') (case @key 'pascal') 'ResponseBody') response.body}}}
{{/if}}
{{#if request.params}}
{{{tsInterface (concat (case ../../gatewayName 'pascal') 'GatewayClient' (case @../key 'pascal') (case @key 'pascal') 'RequestParams') request.params}}}
{{/if}}
{{/each}}
{{/each}}

const handler = async (req: any = {}, urlString: string = '', method = 'get'): Promise<any> => {
  return new Promise((resolve, reject) => {
    try {
      const reqString = JSON.stringify(req.body || {});
      const urlParts = url.parse(urlString);
      
      const pathname = urlParts.pathname.replace(/(:[a-z][^(\.\/)]+)/gi, (a, b) => {
        return req.params[b.substr(1)] ? req.params[b.substr(1)] : b;
      });

      const headers: {
        'Authorization'?: string;
        'Content-Type': string;
        'Content-Length': number;
      } = {
        'Content-Type': 'application/json',
        'Content-Length': Buffer.byteLength(reqString)
      };
      if (localStorage.getItem('authorization')) {
        headers['Authorization'] = localStorage.getItem('authorization');
      }

      const input = http.request(
        {
          protocol: urlParts.protocol,
          host: urlParts.hostname,
          port: urlParts.port,
          path: pathname,
          method,
          headers
        },
        output => {
          let responseString = '';

          output.on('data', chunk => {
            responseString += chunk;
          });

          output.on('end', () => {
            const contentType = output.headers['content-type'];
            const responseBody = contentType.includes('application/json')
              ? JSON.parse(responseString)
              : responseString;
            if (output.statusCode >= 200 && output.statusCode <= 299) {
              const authorization = output.headers['authorization'];
              if (authorization) {
                localStorage.setItem('authorization', authorization);
              }
              resolve({
                statusCode: output.statusCode,
                body: responseBody,
                headers: {
                  authorization,
                  contentType
                }
              });
            } else {
              reject({
                statusCode: output.statusCode,
                body: responseBody,
                headers: {
                  contentType
                }
              });
            }
          });
        }
      );
      input.on('error', reject);
      input.write(reqString);
      input.end();
    } catch (error) {
      reject(error);
    }
  });
}

export class {{{case gatewayName 'pascal'}}}GatewayClient implements I{{{case gatewayName 'pascal'}}}GatewayClient {
  url = 'http://localhost:5000';

  constructor(opts?: I{{{case gatewayName 'pascal'}}}GatewayClientOpts) {
    if (opts && opts.url !== undefined) {
      this.url = opts.url;
    }
  }
  {{#each routes}}

  '{{{./uri}}}': {
    {{#each methods}}
    {{{@key}}}: I{{{case ../../gatewayName 'pascal'}}}GatewayClient{{{case @../key 'pascal'}}}{{{case @key 'pascal'}}}Function;
    {{/each}}
  } = {
    {{#each methods}}
    {{{@key}}}: async (req) => {
      return handler(req, `${this.url}{{{../uri}}}`, '{{{@key}}}');
    }{{#unless @last}},{{/unless}}
    {{/each}}
  };
  {{/each}}
}
